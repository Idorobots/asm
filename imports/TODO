################################################################################
#+TITLE: ASM Standard Library TODO file
# Each category will be a single module.
#
# ? - think/rethink/reimplement
# ! - important
#
#+STARTUP: content
#+SEQ_TODO: NEXT STARTED TEST FIXME DONE
#
# nothing - plannig and designing.
# NEXT - scheduled for implementation.
# STARTED - proper implementation phase.
# TEST - testing phase.
# FIXME - scheduled for bugfixing, unbreaking, etc.
# DONE - sweet, sweet nothing.
####################

* HIGHEST PRIORITY
** Take CEK semantics and BareBones ASM into account.
* Babel
# A module making ASM look and feel like other languages.
- cc.babel
** Lispy
** Pythony
** Algoly
** etc
* Collections
- [X] Generic for all the collection types.
- cc.collections
*** Collection manipulation
- [-] join - if the second argument is a collection - prepends it the
      the first argument, if it's not a collection - joins both
      arguments into a pair. Creates a new collection.
      Examples:
      + (join 1 '[1 2 3]) -> [1 1 2 3]
      + (join '(a b) '[1 2 3]) -> [(a b) 1 2 3]
      + (join 'a 'b) -> (a b)
- [-] append  if argument types match - appends element or a
      collection to another collection, if types don't match - appends
      the second argument to the collection.
      Creates a new collection.
      Examples:
      + (append '[1 2 3] 4) -> [1 2 3 4]
      + (append '[1 2 3] '[4 5 6]) -> [1 2 3 4 5 6]
      + (append '(2 3) '[2 3]) -> (2 3 [2 3])
- [X] first - returns a reference to the first element of a mutable
      collection, or its value for an immutable collection.
- [X] rest - returns a new collection referencing the rest part of
      the old one.
- [X] second, third, fourth etc.
- [X] nth - returns nth element of a collection.
- [X] map - maps an operation to a collection collecting results.
- [X] reduce - maps an operation to a collection reducing it to a
      single value.
- [ ] ? slice - slices a collection creating subcollection.
- [-] ? push, push-back, pop, pop-back.
- ? etc
*** Collection creation
- [X] list - returns a list consisting of the call args.
- [X] tuple - returns a tuple consisting of the call args.
- [X] set - returns a set consisting of the call args.
- [X] scope - reuturns a scope with call args defined in it.
- ? etc.
* Core
- core
*** Type predicates
- [ ] ? Accept multiple args.
- [X] Evaluate to fnord on false, to one of their args otherwise.

- [X] type? - NOT A PREDICATE, returns type tuple of a _single_
      object.
- [X] fnord? - 'yup if an expression is fnord.
- [X] symbol? - symbol if an expression is a symbol.
- [X] number? - number if an expression is a number.
- [X] string? - string if an expression is a string.
- [X] scope? - scope if an expression is a scope.
- [X] function? - function if an expression is a function.
- [X] pure? - pure if an expression is a pure function.
- [X] syntax? - syntax if an expression is a syntax keyword.
- [X] scope? - scope if an expression is repetition, sigh.
- [X] builtin? - builtin if an expression is a builtin.
- [X] immutable? - immutable if an expression is immutable.
- [ ] mutable? - mutable if an expression is not immutable.
*** Type conversions
- [ ] ! Convert in place if passed a settable reference, or create a copy.
- [ ] ? Return fnord on error.

- [ ] ? string->number - numerical value of a string.
- [ ] ? string->symbol - returns a symbol version of a string.
      (both deprecated because of the (read-from-string))
- [-] tupleof:
        + [X] Makes an immutable tuple version of a passed arg.
        + [ ] ? Should work for atoms aswell.
- [-] listof:
        + [X] Makes a list representation of an arg.
        + [ ] ? Should work for atoms too.
- [-] setof:
        + [X] Makes a set representation of an arg.
        + [ ] ? Should work for atoms too.
- [X] ! stringof - Makes a string representation of a passed arg.
- ? etc
*** Working with numbers
- [ ] ASMKit functions accept two arguments.
- [ ] ! Generic functions built ontop of ASMKit ones, directly in ASM.
      Return (reduce ASMKitFunc args).
- [ ] ? Do not use the common operators, so they become redefineable.
**** NEXT ASMKit:
- [ ] * - a * b
- [ ] + - a + b
- [ ] - - a - b
- [ ] / - a / b
- [ ] mod - a modulo b
**** NEXT Generics:
- [ ] sum - generic +
- [ ] mult - generic *
- [ ] sub - generic -
- [ ] div - generic /
- [ ] modulo - generic mod
- ? etc
*** Equality checks
- [ ] ASMKit versions taking only two args.
- [ ] Generic versions returning first arg on true.
**** NEXT ASMKit:
- [ ] eq? - polimorfic equality check.
- [ ] leq? - a <= b
- ? etc
**** NEXT Generics:
- [ ] ? equal?/=/== - generic equal?
- [ ] <= - generic leq?
- [ ] >= - generic ((a eq? b) or (not (a leq? b)))
- [ ] < - generic ((not (a eq? b)) and (a leq? b))
- [ ] > - generic ((not (a eq? b)) and (not (a leq? b)))
* IO
- cc.io
- [ ] ? Using one interface for files, sockets, stdin etc.
*** Input
- [ ] readln - Unformatted (string) reads.
- [ ] read - Formatted reads.
- [ ] ? load/open - Loads a file for reading (as a Scope/Stream with read
      defined acordingly).
- [ ] ? close - closes an imput stream.
- [ ] eof? - returns 'yup/the object if it has reached EOF.
- ? etc
*** Output
- [X] write - writes string representation of the args.
- ? etc
* Error
- core.error
# Merge with Core?
- [ ] ? error! - throws an error caugth by the REPL.
- [ ] ? warning! - prints a warning/throws an error if 'serious
      bussiness' was enabled..
- [-] ? catch - catches a thrown error. (Name `handle-error'?)
- [ ] ? assert! - checks a condition and throws an error on failure.
- ? etc
* GC
- core.gc
# Merge with core?
- [ ] collect! - does a collection.
- [ ] minimise! - minimises memory use.
- [ ] stop! - stops GC.
- [ ] resume! - resumes GCs work.
* Math
- cc.math
- ? Precompiled.
- [ ] sqrt
- [ ] pow
- [ ] exp
- [ ] min/max/clamp
- ? etc
* Parser
# Merge with core?
- [ ] syntax! - defines a new reader syntax macro.
- [ ] ? parse - parses an input string. (Name read-from-string).
* Random ideas
** Must-have DSLs
Will allow for awesome stuff like this:

#+begin_example
(module Moo
  #? (ASMdoc Function func, doing some stuff and returning other stuff.)
  private (function (func tuple)
            in:
              (or (tuple? tuple)
                  (vector? tuple))
            out:
              (number? result)
            body:
              (loop for element in tuple
                    do (switch element
                         case 1 (write "One!")
                         case 2 (write "Two!")
                         default (let foo (/ element 2)
                                  let bar (% element 2)
                                  do (write (* element
                                               (- foo bar)))))))
          (unittest functest
            assert (equal? (func '(1 2 3)) 23)
            finally (print "Passed!"))
  public (var bar 23))

(import func from Moo as Moofunc)

(Moofunc '[1 2 3]) # writes "One! Two! 3

#+end_example

*** Loop
Common Lisp like loop macro:

(loop for foo in bar
      for baz being each hash-key of goo
      when gaz
      do gar)

*** Unittest
Automated unittest runner:

(unittest Foo
    assert (equal? bar baz)
    assert (foo bar baz)
  test Bar
    assert (foo bar baz)
    assert (foo bar baz)
    log "herp derp"
  test Baz
    assert (bar foo faz)
  finally (derp herp))

*** Let
Purely binds variables to values (transforms the body into a lambda
call):

(let foo (bar baz)
 let faz (foo gaz)
 do (foo faz))

*** Switch
Switch-like control structure, with fallthrough + case goto, case
ranges etc:

(switch a
  case b (foo bar baz)
  case c (faz baz baz)
  default foo)

*** Module/program/class/application etc
Wraps a bunch of functions and state into a single, named unit:

(module Foo
  private (function (foo bar baz)
            (bar baz baz))
  public (var bar)
  export (function (herp derp)
           (derp derp derp)))

Dependancy injection:

(module Math (printer alocator)
  (function (matrix m n)
    (alocator.malloc (* bar baz)))

  (function (printm matrix)
    (forech e in matrix
            do (printer.print e))))

(import (Math my-logger kewl-alocator))

(Math.printm (Math.matrix 3 3))

*** Function
Creates a function with all kinds of cool stuff:

(function (foo bar baz)
  in (equal? bar 23)
  in (> baz bar)
  out (< result bar)
  body (bar baz))

*** Import
Imports symbols, loads modules, manages scopes:

(import func from ModuleA as AFunc
        all from ModuleB)

*** SVG
Returns a wellformed SVG string:

(SVG 100 100
     (circle 50 50
             '(255 255 100)))

*** LaTeX
Returns a wellformed LaTeX string:

(LaTeX
  "The following equation is herp derp derp:"
  (equation "a^2 + b^2 = c^2")
  (equation "\herp = \derp"))
*** Docs
Used for documenting code, using... code in the comments.
Something along these lines (needs more work):

#? (ASMdoc
#?   This function does some stuff and returns other stuff.
#?   --params
#?       bar - an integer,
#?   --returns - another integer,
#?   --example
#?        (var baz (foo 23))
#? )
(function foo (bar)
  (doStuff bar))
** Must-have tools
*** ASM AST/dependancy -> graphviz utility.                            :NOTE:
[2012-05-16 śro 23:14]
[[file:~/notes/science/net/net.org]]
** Other stuff
*** Vectorize macro for ASM.                                           :NOTE:
(macro vectorize (fun)
  (let ((old-fun (gensym)))
    `(let (($old-fun $fun))
       (function $fun (vec)
         (map fun vec)))))
[2012-05-20 nie 02:10]
[[file:~/org/general.org::*Install%20GDC%20on%20PiWL.][Install GDC on PiWL.]]
*** if-non-fnord syntax for ASM                                        :NOTE:
foo ? bar == (if-non-fnord foo bar) == (if foo foo bar)

Implementation:

(macro if-non-fnord (foo bar)
  (let ((_foo (gensym)))
    `(let (($_foo $foo))
       (if $_foo
           $_foo
           $bar))))

(syntax "\?" (parsed parsing)
  `(if-non-fnord $(pop-front! parsed)
                 $(read-expression! parsing)))


Example:
# map - 1d or 2d list
(let ((leny (length map))
      (lenx (length (car map)) ? 1))
  (do-stuff lenx leny) ? 23)

# Expands to:
(let ((leny (length map))
      (lenx (if-non-fnord (length (car map))
                          1)))
  (if-non-fnord (do-stuff lenx leny)
                23))

# Expands to:
(let ((leny (length map))
      (lenx (let ((__GENSYM0 (length (car map))))
              (if __GENSYM0
                  __GENSYM0
                  1))))
  (let ((__GENSYM1 (do-stuff lenx leny)))
    (if __GENSYM1
        __GENSYM1
        23)))
[2012-05-16 śro 19:27]
[[file:~/org/refile.org]]
*** Whitespace aware syntax for ASM                                    :NOTE:
(package foo
  (function (bar arg0 arg1)
    (if (and (atom? arg0)
             (atom? arg1))
        (* arg0 arg 1)
        (apply + (append arg0 arg1))))
  (var gun (bar 2 3)))

     ||
    \||/
     \/

package foo
  function (bar arg0 arg1)
    if and atom? arg0
           atom? arg1
       (* arg0 arg1)
       apply +
             (append arg0 arg1)
  var gun
      (bar 1 2)

[2012-05-24 czw 13:11]
[[file:~/org/refile.org]]
*** Immutable let and mutable var                                      :NOTE:
(let ((foo bar))
  # foo is immutable
)

(var ((foo bar))
  # foo is mutable
)
[2012-05-25 pią 15:17]

** The reader
# Defined in experimental.parser2
