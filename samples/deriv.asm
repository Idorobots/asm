# Classic SICP stuff

(macro i () '(import 'experimental.deriv))

(var length length?)
(var cons join)
(var car first)
(var cadr (lambda (x) (car (cdr x))))
(var caddr (lambda (x) (car (cdr (cdr x)))))
(var cdr rest)
(var cddr (lambda (x) (cdr (cdr x))))
(var cond if*)

(function deriv (expr var)
  (cond ((number? expr) 0)
        ((variable? expr)
         (if (same-variable? expr var) 1 0))
        ((sum? expr)
         (make-sum (deriv (addend expr) var)
                   (deriv (augend expr) var)))
        ((product? expr)
         (make-sum (make-product (multiplier expr)
                                 (deriv (multiplicand expr) var))
                   (make-product (deriv (multiplier expr) var)
                                 (multiplicand expr))))
        ((exponentiation? expr)
         (make-product (make-product (exponent expr)
                                     (make-exponentiation (base expr)
                                                          (- (exponent expr) 1)))
                       (deriv (base expr) var)))
        ('else (error "Unknown operation."))))

(var variable? symbol?)

(function same-variable? (a b)
  (and (and (variable? a)
            (variable? b))
       (equal? a b)))

(function make-sum (a b)
  (cond ((=number? a 0) b)
        ((=number? b 0) a)
        ((and (number? a)
              (number? b))
         (+ a b))
        ((sum? b)
         (append `(+ $a) (cdr b)))
        ('else `(+ $a $b))))

(function make-product (a b)
  (cond ((or (=number? a 0)
             (=number? b 0))
         0)
        ((=number? a 1) b)
        ((=number? b 1) a)
        ((and (number? a)
              (number? b))
         (* a b))
        ((product? b)
         (append `(* $a) (cdr b)))
        ('else `(* $a $b))))

(function make-exponentiation (x n)
  (cond ((=number? n 0) 1)
        ((=number? n 1) x)
        ((and (number? x)
              (number? n))
         (pow x n))
        ('else `(pow $x $n))))

(function sum? (e)
  (and (tuple? e)
       (equal? (car e) '+)))

(function product? (e)
  (and (tuple? e)
       (equal? (car e) '*)))

(function exponentiation? (e)
  (and (tuple? e)
       (equal? (car e) 'pow)))

(var addend cadr)
#(var augend caddr)

(function augend (e)
  (cond ((simple-operation? e)
         (caddr e))
        ('else (cons '+ (cddr e)))))

(var multiplier cadr)
#(var multiplicand caddr)

(function multiplicand (e)
  (cond ((simple-operation? e)
         (caddr e))
        ('else (cons '* (cddr e)))))

(var base cadr)
(var exponent caddr)

(function =number? (x e)
  (and (number? x)
       (equal? x e)))

(function simple-operation? (e)
  (and (or (sum? e)
           (product? e))
       (equal? (length e) 3)))