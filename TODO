################################################################################
# ASM & ASM interpreter TODO file. Use Emacs org-mode to browse!
#
# ? - think/rethink/reimplement
# ! - important
#
#+STARTUP: content
#+SEQ_TODO: NEXT STARTED TEST FIXME DONE
#
# nothing - plannig and designing.
# NEXT - scheduled for implementation.
# STARTED - proper implementation phase.
# TEST - testing phase.
# FIXME - scheduled for bugfixing, unbreaking, etc.
# DONE - sweet, sweet nothing.
####################

* HIGHEST PRIORITY
** Drop the OOP and merge CEK architecture vm.
* THINGS TO DO IN THE INTERPRETER
# Lists things needing attention in the interpreter.
- Decouple VM code from DASM code - making DSM only use VM as the
  run-time environment.

** dasm.lexical
*** Syntax
- [ ] ! Remove enum Syntax.
- [ ] ! Minimise enum Lexical.
- [X] Split to Lexical and Syntax:
    + [X] CommentStart, EndOfLine etc - Lexical
    + [X] Rest - Syntax
*** Syntax keywords
- [ ] Sort out which keywords are crucial and leave only those.
- [ ] Sort the list and write proper descriptions.
- [ ] ? Self:
    + ? Used only for representation of Collections/Scopes/Functions.
    + ? Used semanticly as a self reference of an object.
- [ ] ? Embed:
    + ? Rename to something more appropriate.
    + ? Make it evaluate the expression twice.
- [ ] ? Add __scopecall etc keywords.
*** Semantic keywords
- [ ] ? Add a list of builtin, recognised keywords.
- ? Merge with Comments and their opts?
** dasm.ast
*** Type
*** Semantic analyzis
- [ ] ? Type primitive used for semantic analyzis.
- [ ] version(safe) toggling parts of semantic analyzis.
- [ ] Type checking, and predictedType field in Expression.
- [-] Arg number and type checking in Callables:
    + [X] Arg number checking.
    + [-] Arg type checking.
    + [ ] AbigiousCall error when types can vary greatly. E.g. Many
          ifs returning many different expressions.
- [ ] ? Arg evaluation list building using thunks.
- [ ] Recursion depth checking.
*** Expression
- [X] Additional fields:
    + [X] Line number.
    + [X] Filename.
    + [X] Semantic keywords.
- [ ] ? opApply instead of range(), for convinience. Maby both?
- [ ] T value(T)() instead of real value().
- [ ] hash_t toHash();
- [X] bool opEquals(Object);
- [ ] int opCmp(Object);
*** Atom
- [X] Take the string away from there, make it a proper immutable
      collection.
- [ ] Add more numerical types.
- [ ] ? Add common atomic operations (like math for numbers, etc).
*** Collection
- [-] call() for Set and List with no implementation for Tuple:
  + [X] call() for Set and List.
  + [ ] No compiled implementation for Tuple.
- [X] Set.call() calling "__setcall".
- [X] List.call() calling "__listcall".
- [X] List evaluating to "__listeval".
- [X] Set evaluating to "__seteval".
- [X] Add "evalKeyword" and "callKeyword" template args to make eval()
      a oneliner.
- [X] Collection specialisation for String.
- [ ] Proper implementation of the Tuple - linked list.
- [ ] Proper implementation of the Set - kind of a BST.
- [X] Rename List to Vector.
*** Callable
- [ ] ! Depth parameter for the calls.
- [X] String representation actually showing the callable.
*** Scope
- [X] ? String representation actually being usefull. (A tuple of
      keys or key/value pairs.)
- [X] One lexical scope of the variables, macros and syntax keywords.
- [ ] Additional scope for the actual syntax.
- [X] define()
- [ ] syntax()
- [X] Remove set().
- [ ] ? Add undefine(string).
- [ ] ? Add merge(Scope).
- [ ] ? Add import(Scope).
- [X] Add isDefined(string).
- [X] Scope.call() calling "__scopecall".
- [X] Fix storing unwanted objects when rebinding symbols.
*** HashTable
- [ ] ? New syntax: #[(key value)]
- [ ] ? HashTable.call() returning val-ref / (key val-ref) or UnitType.
    + ? Has to return settable ref at all times (for use with set!).
- [ ] ? HashTable.eval() returning Scope.
- [ ] ? Merge this with Scope.
** dasm.kit
- [ ] ? Move pass() to a separate module.
- [X] Actually write some fooking implementations.
- [ ] Sort out which implementations are crucial for the language.
- [X] Move Scope, Set and List calls there:
    + [X] Set.call()
    + [X] Scope.call()
    + [X] List.call()
- [X] Move Set, List and Tuple evals there:
    + [X] Set.eval()
    + [X] List.eval()
    + [X] Tuple.eval()
- [X] Fix FNORD comparisions:
*** Implementations
- [-] Fix EMBED, QUOTE and QQOTE on strings.
- [-] Find solution to/report ref parameter delegate bug from
      LAMBDA.
- [ ] Keyword dispatch for Callables declarators.
- [ ] ? Make IMPORT work with default import paths etc.
- [X] Fix SETOF, TUPLEOF, LISTOF.
- [X] GET should evaluate it's args.
- [X] Rename FUNCTION to LAMBDA/ANONYMOUS.
- [ ] ! LAMBDA should accept multiple expressions in a body.
*** Unittests
- [X] Actually write those.
- [X] Write more of these.
- [ ] Write even more of these.
- [ ] Foookin' unittest, man!
** dasm.parser
*** Transition
- [ ] Make the parser minimalistic with no extended syntax, nor
      code validation.
- [ ] Rewrite Core to parse on it.
- [ ] Write a recursive descent parser in ASM.
*** DefaultParser
- [X] Stop ESyntax expansion in symbols. E.g. some$ymbol.
- [ ] Make parse() pretier!
- [ ] Fix number parsing and PhobosBug(TM) workarrounds.
- [ ] ? NumberParser
*** StringParser
- [ ] ? Plan embedding representation.
- [ ] Actually parsing strings.
- [ ] Recognize escape sequences.
- [ ] Recognize expression embeds.
*** Unittests
- [ ] Make unittests Syntax independant.
- [X] More preprocess() unittests.
- [X] More tokenize() unittests.
- [ ] ? parse() unittests.
*** Metadata
- [X] Add file data.
- [X] Add line number data.
- [ ] ? Add column number data.
** dasm.vm
- [ ] ? Move already implemented ASMKit functions to dasm.kit.
- [X] Fix doString() and doFile().
- [ ] ? InterpretingError for file interepretation.
- [-] Fix metadata in error messages.
*** Unittests
- [X] Actually write those.
- [ ] Write more of these.
- [ ] Write even more of these.
- [ ] Foookin' unittest, man!
** dasm.main
*** Interpreter switches
- --barebones | --bb - won't load anything. Will try interpreting only
  BareBonesASM code.
- --path - sets a search path for imports.
- --help | -h - lists all the switches.
- --version | -v - prints out the version number.
- --license - prints out the licensing info.

################################################################################
* RANDOM IDEAS
# Lists some ideas yet to be moved to a more apropriate place.

** Loading symbols from a .so
- [ ] Find a way to walk arround D's unfinished stuff. *awesome happy face*
- [ ] Find a way to precompile libraries.
- [ ] Find a way to load precompiled files into the ASM.
- [ ] Find a way to call C code directly (a low level proc perhaps?).
** Collections
- [ ] Expression[] range() -> Range range()
- [ ] += Range:
      + Containing all required Range methods.
      + opIndex()
      + opSlice()
      + opDollar()
*** correct Tuple
- [ ] Made out of immutable conses for structure sharing.
- [ ] (elements) and (elements , a)
*** correct Set
- Figure out if it's actually needed.
- [ ] AVL/Red-Black tree/Heap.
- [ ] Unordered.
- [ ] Multiset.
- [ ] {elements}
*** correct Vector
- [X] Dynamic array.
- [X] That be it yo.
- [X] [elements]
*** HashTable
- [ ] #[(k v) (k v)] or #!HashTable [(k v) (k v)]
*** Scope
- ? $(contents same as HashTable) or #!Scope [(k v) (k v)]
- ? Same as HashTable?
*** Array/String
- [ ] | atomic elements |
- [ ] "special literal for character string"
- Think about element evaluation problem.
** Callables
*** Functions
- [ ] ? Purity checks when defining a lambda.
- [ ] Pure functions being memoized by default.
- [ ] ? Simple literals:
      + [ ] [args -> body] - lexically scoped closure.
- [ ] ? Arg dispatch:
      + [ ] (lambda args body) -> 0-INF-ary, args store all the call args.
      + [ ] (lambda (a . b) body) -> N-INF-ary, b stores the rest of
            the call args.
*** Continuations
** Error handling
- [ ] (catch e handler) -> (try e handler0 handler1 ...)
- [ ] handler = (error-object handling-function)
- [ ] (error error-object/string)
** Lazy evaluation
- [X] Native, first-clas Promise.
- [X] Builtin (lazy e) macro.
- [ ] ? Builtin (force e) macro for disambiguation.
- [ ] ? Lazyfy builtins.
** Reader architecture
1. BareBonesASM - a subset of the language consisting of the most low
   level functions. Possibly the bytecode calls for the VM.
2. Hardcoded parser that parses _only_ BareBonesASM.
3. The language implementation
- Core modules written directly in BareBonesASM.
- Reader implemented in BareBonesASM.
