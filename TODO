################################################################################
# ASM & ASM interpreter TODO file. Use Emacs org-mode to browse!
#
# ? - think/rethink/reimplement
# ! - important
#
#+STARTUP: content
#+SEQ_TODO: NEXT STARTED TEST FIXME DONE
#
# nothing - plannig and designing.
# NEXT - scheduled for implementation.
# STARTED - proper implementation phase.
# TEST - testing phase.
# FIXME - scheduled for bugfixing, unbreaking, etc.
# DONE - sweet, sweet nothing.
####################

* HIGHEST PRIORITY
** Drop the OOP and merge CEK architecture vm.
* THINGS TO DO IN THE INTERPRETER
# Lists things needing attention in the interpreter.
- Decouple VM code from DASM code - making DSM only use VM as the
  run-time environment.

** dasm.lexical
*** Syntax
- [ ] ! Remove enum Syntax.
- [ ] ! Minimise enum Lexical.
- [X] Split to Lexical and Syntax:
    + [X] CommentStart, EndOfLine etc - Lexical
    + [X] Rest - Syntax
*** Syntax keywords
- [ ] Sort out which keywords are crucial and leave only those.
- [ ] Sort the list and write proper descriptions.
- [ ] ? Self:
    + ? Used only for representation of Collections/Scopes/Functions.
    + ? Used semanticly as a self reference of an object.
- [ ] ? Embed:
    + ? Rename to something more appropriate.
    + ? Make it evaluate the expression twice.
- [ ] ? Add __scopecall etc keywords.
*** Semantic keywords
- [ ] ? Add a list of builtin, recognised keywords.
- ? Merge with Comments and their opts?
** dasm.ast
*** Type
*** Semantic analyzis
- [ ] ? Type primitive used for semantic analyzis.
- [ ] version(safe) toggling parts of semantic analyzis.
- [ ] Type checking, and predictedType field in Expression.
- [-] Arg number and type checking in Callables:
    + [X] Arg number checking.
    + [-] Arg type checking.
    + [ ] AbigiousCall error when types can vary greatly. E.g. Many
          ifs returning many different expressions.
- [ ] ? Arg evaluation list building using thunks.
- [ ] Recursion depth checking.
*** Expression
- [X] Additional fields:
    + [X] Line number.
    + [X] Filename.
    + [X] Semantic keywords.
- [ ] ? opApply instead of range(), for convinience. Maby both?
- [ ] T value(T)() instead of real value().
- [ ] hash_t toHash();
- [X] bool opEquals(Object);
- [ ] int opCmp(Object);
*** Atom
- [X] Take the string away from there, make it a proper immutable
      collection.
- [ ] Add more numerical types.
- [ ] ? Add common atomic operations (like math for numbers, etc).
*** Collection
- [-] call() for Set and List with no implementation for Tuple:
  + [X] call() for Set and List.
  + [ ] No compiled implementation for Tuple.
- [X] Set.call() calling "__setcall".
- [X] List.call() calling "__listcall".
- [X] List evaluating to "__listeval".
- [X] Set evaluating to "__seteval".
- [X] Add "evalKeyword" and "callKeyword" template args to make eval()
      a oneliner.
- [X] Collection specialisation for String.
- [ ] Proper implementation of the Tuple - linked list.
- [ ] Proper implementation of the Set - kind of a BST.
- [X] Rename List to Vector.
*** Callable
- [ ] ! Depth parameter for the calls.
- [X] String representation actually showing the callable.
*** Scope
- [X] ? String representation actually being usefull. (A tuple of
      keys or key/value pairs.)
- [X] One lexical scope of the variables, macros and syntax keywords.
- [ ] Additional scope for the actual syntax.
- [X] define()
- [ ] syntax()
- [X] Remove set().
- [ ] ? Add undefine(string).
- [ ] ? Add merge(Scope).
- [ ] ? Add import(Scope).
- [X] Add isDefined(string).
- [X] Scope.call() calling "__scopecall".
- [X] Fix storing unwanted objects when rebinding symbols.
*** HashTable
- [ ] ? New syntax: #[(key value)]
- [ ] ? HashTable.call() returning val-ref / (key val-ref) or UnitType.
    + ? Has to return settable ref at all times (for use with set!).
- [ ] ? HashTable.eval() returning Scope.
- [ ] ? Merge this with Scope.
*** Promise
- [ ] Fix the force macro to force all the way instead of one level.
- [ ] Add memoize macro.
** dasm.kit
- [ ] ? Move pass() to a separate module.
- [X] Actually write some fooking implementations.
- [ ] Sort out which implementations are crucial for the language.
- [X] Move Scope, Set and List calls there:
    + [X] Set.call()
    + [X] Scope.call()
    + [X] List.call()
- [X] Move Set, List and Tuple evals there:
    + [X] Set.eval()
    + [X] List.eval()
    + [X] Tuple.eval()
- [X] Fix FNORD comparisions:
*** Implementations
- [-] Fix EMBED, QUOTE and QQOTE on strings.
- [-] Find solution to/report ref parameter delegate bug from
      LAMBDA.
- [ ] Keyword dispatch for Callables declarators.
- [ ] ? Make IMPORT work with default import paths etc.
- [X] Fix SETOF, TUPLEOF, LISTOF.
- [X] GET should evaluate it's args.
- [X] Rename FUNCTION to LAMBDA/ANONYMOUS.
- [ ] ! LAMBDA should accept multiple expressions in a body.
*** Unittests
- [X] Actually write those.
- [X] Write more of these.
- [ ] Write even more of these.
- [ ] Foookin' unittest, man!
** dasm.parser
*** Transition
- [ ] Make the parser minimalistic with no extended syntax, nor
      code validation.
- [ ] Rewrite Core to parse on it.
- [ ] Write a recursive descent parser in ASM.
*** DefaultParser
- [X] Stop ESyntax expansion in symbols. E.g. some$ymbol.
- [ ] Make parse() pretier!
- [ ] Fix number parsing and PhobosBug(TM) workarrounds.
- [ ] ? NumberParser
*** StringParser
- [ ] ? Plan embedding representation.
- [ ] Actually parsing strings.
- [ ] Recognize escape sequences.
- [ ] Recognize expression embeds.
*** Unittests
- [ ] Make unittests Syntax independant.
- [X] More preprocess() unittests.
- [X] More tokenize() unittests.
- [ ] ? parse() unittests.
*** Metadata
- [X] Add file data.
- [X] Add line number data.
- [ ] ? Add column number data.
** dasm.vm
- [ ] ? Move already implemented ASMKit functions to dasm.kit.
- [X] Fix doString() and doFile().
- [ ] ? InterpretingError for file interepretation.
- [-] Fix metadata in error messages.
*** Unittests
- [X] Actually write those.
- [ ] Write more of these.
- [ ] Write even more of these.
- [ ] Foookin' unittest, man!
** dasm.main
*** Interpreter switches
- --barebones | --bb - won't load anything. Will try interpreting only
  BareBonesASM code.
- --path - sets a search path for imports.
- --help | -h - lists all the switches.
- --version | -v - prints out the version number.
- --license - prints out the licensing info.

################################################################################
* RANDOM IDEAS
# Lists some ideas yet to be moved to a more apropriate place.

** Loading symbols from a .so
- [ ] Find a way to walk arround D's unfinished stuff. *awesome happy face*
- [ ] Find a way to precompile libraries.
- [ ] Find a way to load precompiled files into the ASM.
- [ ] Find a way to call C code directly (a low level proc perhaps?).
** Collections
- [ ] Expression[] range() -> Range range()
- [ ] += Range:
      + Containing all required Range methods.
      + opIndex()
      + opSlice()
      + opDollar()
*** correct Tuple
- [ ] Made out of immutable conses for structure sharing.
- [ ] (elements) and (elements , a)
*** correct Set
- Figure out if it's actually needed.
- [ ] AVL/Red-Black tree/Heap.
- [ ] Unordered.
- [ ] Multiset.
- [ ] {elements}
*** correct Vector
- [X] Dynamic array.
- [X] That be it yo.
- [X] [elements]
*** HashTable
- [ ] #[(k v) (k v)] or #!HashTable [(k v) (k v)]
*** Scope
- ? $(contents same as HashTable) or #!Scope [(k v) (k v)]
- ? Same as HashTable?
*** Array/String
- [ ] | atomic elements |
- [ ] "special literal for character string"
- Think about element evaluation problem.
** Callables
*** Functions
- [ ] ? Purity checks when defining a lambda.
- [ ] Pure functions being memoized by default.
- [ ] ? Simple literals:
      + [ ] [args -> body] - lexically scoped closure.
- [ ] ? Arg dispatch:
      + [ ] (lambda args body) -> 0-INF-ary, args store all the call args.
      + [ ] (lambda (a . b) body) -> N-INF-ary, b stores the rest of
            the call args.
*** Continuations
** Error handling
- [ ] (catch e handler) -> (try e handler0 handler1 ...)
- [ ] handler = (error-object handling-function)
- [ ] (error error-object/string)
** Lazy evaluation
- [X] Native, first-clas Promise.
- [X] Builtin (lazy e) macro.
- [ ] ? Builtin (force e) macro for disambiguation.
- [ ] ? Lazyfy builtins.
** Reader architecture
1. BareBonesASM - a subset of the language consisting of the most low
   level functions. Possibly the bytecode calls for the VM.
2. Hardcoded parser that parses _only_ BareBonesASM.
3. The language implementation
- Core modules written directly in BareBonesASM.
- Reader implemented in BareBonesASM.

** User code interface

#+begin_src d
struct Test {
    int bar;
    string foo;
}

// ...

    ASM.defineType!Test;

    ASM.define("foobar", (scpe, args) {
        if(args.car.type == Type.UserDefined)
        if(args.car.userType == typeid(Type))
        // Do shit
        return ASM.fnord;
    });

    ASM.doString(q{
        (var baz (scope
                   (var _inner (newTest))

                   (function getFoo ()
                     (getTestFoo _inner))
                   (function setFoo (newVal)
                     (setTestFoo _inner newVal))

                   (function getBar ()
                     (getTestBar _inner))
                   (function setBar (newVal)
                     (setTestBar _inner newVal))))
        ((baz setFoo) "Test")
        (foobar baz)
        (writeln (baz getBar))
    });
#+end_src
** Array and Vector range primitives
(%acar array) -> newCell(ArrayVal(array[0]));
(%acdr array) -> newCell(array[1 .. $]);
(%vcar vector) -> newCell(vector[0]);
(%vcdr vector) -> newCell(vector[1 .. $]);

CellArray? Merge Vector and Array?

[2012-05-11 piÄ… 10:33]
[[file:~/code/assembly/tests/lab_6a_asm.s::facta:%20pushl%20%25ebp][file:~/code/assembly/tests/lab_6a_asm.s::facta: pushl %ebp]]
** Compound types for ASM using sealer/unsealer functions.
# Could be a hash.
(var *compound-type* 0)

# Could use a separate Q type (Type?) and make use of unique references and is? predicate.
(function make-type ()
  (do (var t *compound-type*)
      (set! *compound-type* (+ 1 *compound-type*))
      (tuple t
             (lambda (o)
               (cons t o))
             (lambda (o)
               (if (and (tuple? o)
                        (equal? (car o) t))
                   (cdr o)
                   (error "Type mismatch."))))))
(function typeof (o)
  (when (pair? o)
    (car o)))

(var (T sealT unsealT) (make-type))

(var foo (sealT (tuple 1 2 3)))

# Might facilitate predicate-based type pattern matching.
(function baz (v)
  (case (typeof v)
    (T (unsealT v))
    (X (unsealX v))
    ...))

[2012-08-07 wto 18:05]
[[irc:/irc.freenode.net:6667/#udacity][irc session 'irc.freenode.net:6667/#udacity']]
** Dynamic dispatch
(defmethod foo (bar baz) body) (foo bar baz) <=> ((get bar 'foo)
baz) # Dynamic dispatch
or
(with bar (foo baz)) # With macro
or
(function foo (baz) body) (connect bar foo) # Slots
* Paper notes
** Memory model
*** Tag
: 15 [--|---|--|-|--------] 0
:      ^  ^  ^  ^     ^
:      |  |  |  |     |_ 8 type/operator bits
:      |  |  |  |_ 1 immutability bit
:      |  |  |_ 2 cons packing bits (optional)
:      |  |_ 3 unused bits (reserved for future use)
:      |_ 2 GC bits (may require more)

*** Tagged pairs
Layout:
: x86   - [-2-|--4--|--4--]                 ---> 10
:         [-2-|x2x|--4--|--4--]             ---> 12, word-aligned
: amd64 - [-2-|----8----|----8----]         ---> 18
:         [-2-|xxx6xxx|----8----|----8----] ---> 24, word-aligned
:         [-2-|---6---|----8----]           ---> 16, word-aligned, memory magic

Variants:
: [TAG|--PTR--|--PTR--] ---> pairs, closures, native calls
: [TAG|--NUM--|--PTR--] ---> arrays, vectors
: [TAG|--NUM--|--NUM--] ---> complex numbers
: [TAG|--- -BIGNUM----] ---> long numbers, thread ids, etc

Cons:
- Numbers will have dangling padding.
- All nulls are explicit and take a word each.
- Characters can't really be referenced directly and require lots of
  space.
- Can't pack conses easily.
- Might not be suitable for non-lisp languages.

Pros:
- Simple implementation and use.
- Maps to Lisp directly.

*** QValues
Layout:
: x86   - [-2-|--4--]     ---> 6
:         [-2-|x2x|--4--] ---> 8, word-aligned
: amd64 - [-2-|----8----] ---> 10
:         [-2-|---6---]   ---> 8, word-aligned, memory-magic

Variants:
: [TAG|--PTR--] ---> anything that uses pointers
: [TAG|--NUM--] ---> anything that uses values

Cons:
- No big numbers without any special treatment.
- Interfacing arrays and native calls to D will be complicated.
- Tag might need additional cons-packing bits.
- Tag appears twice in a pair.

Pros:
- Doesn't need as much padding.
- No dangling null pointers.
- Cons packing is trival.
- Allows for many different kinds of objects to be implemented.
- Allows other kinds of languages to be implemented.
- Maps to Lisp well (was used in Lisp machines).

Cons packing:
: [00|--VAL--]              ---> car is (at) val, cdr is null
: [01|--VAL1-][TAG|--VAL2-] ---> car is (at) val1, cdr is val2
: [10|--VAL1-][TAG|--VAL2-] ---> car is (at) val1, cdr is at val2
: [11|--VAL--]              ---> unused

*** GC
# TODO

GC bits:
: [00|--VAL--] ---> unmanaged (pinned)
: [01|--VAL--] ---> undecided
: [10|--VAL--] ---> undecided
: [11|--VAL--] ---> undecided

*** Allocator
# TODO

** Operators
Always pairs ---> type part of the tag can be used as the operator type.

Example:

(%foo bar baz) is...

: [%foo|-car-|-cdr-]--->[tag|baz]
:         |
:         v
:         [tag|bar]

...instead of...

: [pair|-car-|-cdr-]--->[pair|-car-|-cdr-]--->[tag|baz]
:         |                     |
:         v                     v
:         [tag|%foo]            [tag|bar]

*** Threading
- %tid - returns current threads ID.
- %spawn - spawns a thread evaluating given bytecode.
- %send - sends a bunch of immutable data to a thread.
- %receive - receives a bunch of data.

** Architecture
*** Environment
: +----------------------+
: |     Environment      |
: |+--------------------+|
: ||      Compiler      ||
: ||+------------------+||
: |||        VM        |||
: ||+------------------+||
: |+-----------------^--+|
: +-------^----^-----|---+
:     ^   |    |     |
:     |   |    |     |
:      ASM    BSM   CSM

Source types:
- .asm - high level ASM.
- .bsm - human-readable barebones ASM.
- .csm - raw, compiled bytecode

*** Compiler
# TODO

*** VM
:       +------+
: C --->|      |
: E --->|      |
: H --->|  S   |
: K --->|      |
: M --->|      |
:       +------+

Registers:
- S - store (memory)
- C - code being dispatched
- E - environment stack
- H - handler stack
- K - continuation stack
- M - metacontinuation stack
** Interfacing with D
*** Native calls
Implementation:
: [native|ptr|func]---> raw D function
:          |
:          v
:       memory location containing the closure

Example usage:
: ASM.define("foo", x => x);
: ASM.foo = x => x;

*** Native types
Implementation:
: [user-type|type|data]---> raw D data
:             |
:             v
:          D typeid

Example usage:
: ASM.define!SomeType;

*** Dynamic FFI
# TODO, use libffi. Python ctypes style.
** Continuations
*** @ register
Instead of value stores the return address where the value should be
stored.

*** Metacontinuations
Additional M stack containing continuation segments.

: (%done @)    (%halt @)
:     ^            ^
:     |            |
: (  ...  )        |
:     ^            |
:     |            |
: (  ...  )        |
:          ^       |
:           \      |
: (%done @)  (%restore @)
:     ^            ^
:     |            |
:     K            M

Primitives:
- %restore - sets K to the stored continuation stack segment and applies it to the continuation hole.
- %done - ends the current continuation segment and invokes the M register.
- %halt - ends the flow of the program.

*** Generalized metacontinuations
Multiple metacontinuation stacks with multiple segments each.

: (%done @)    (%done @)      (%halt @)   ...
:     ^            ^              ^
:     |            |              |
: (  ...  )        |              |
:     ^            |              |
:     |            |              |
: (  ...  )<--(%restore @)        |
:                  ^              |
: (%done @)        |              |
:     ^            |              |
:     |            |              |
: (  ...  )        |              |
:     ^            |              |
:     |            |              |
: (  ...  )<--(%restore @)<--(%restore @)
:                                 ^
: (%done @)    (%done @)          |
:     ^            ^              |
:     |            |              |
: (  ...  )<--(%restore @)<--(%restore @)
:                                 ^
: (%done @)    (%done @)          |
:     ^            ^              |
:     |            |              |
: (  ...  )<--(%restore @)        |
:                  ^              |
: (%done @)        |              |
:     ^            |              |
:     |            |              |
:    MK0          MK1            MK2      ...

Primitives:
- %restore - pushes a stored continuation stack segment onto the MK register.
- %done - pops the MK register leaving the rest of the meta-stack.
- %halt - ends the flow of the program.

Possible primitives:
- %done-if - premature MK register poping (if @ != ()).
- %select - depending on @ pushes one of its children onto the MK stack.

Notes:
- Might be really cool. Especially because it doesn't require constant consing of the continuation stack.
- All the code can be pre-transformed into dataflow format and then executed with no further transformations.
- Used to implement delimited continuations.
