################################################################################
# ASM & ASM interpreter TODO file. Use Emacs org-mode to browse!
#
# ? - think/rethink/reimplement
# ! - important
#
#+SEQ_TODO: NEXT STARTED TEST FIXME DONE
#
# nothing - plannig and designing.
# NEXT - scheduled for implementation.
# STARTED - proper implementation phase.
# TEST - testing phase.
# FIXME - scheduled for bugfixing, unbreaking, etc.
# DONE - sweet, sweet nothing.
####################

* THINGS TO DO IN THE LIBRARY:
# Each category will be a single module.

** Collections:
- [X] Generic for all the collection types.
*** Collection manipulation:
- [-] join - if the second argument is a collection - prepends it the
      the first argument, if it's not a collection - joins both
      arguments into a pair. Creates a new collection.
      Examples:
      + (join 1 '[1 2 3]) -> [1 1 2 3]
      + (join '(a b) '[1 2 3]) -> [(a b) 1 2 3]
      + (join 'a 'b) -> (a b)
- [-] append  if argument types match - appends element or a
      collection to another collection, if types don't match - appends
      the second argument to the collection.
      Creates a new collection.
      Examples:
      + (append '[1 2 3] 4) -> [1 2 3 4]
      + (append '[1 2 3] '[4 5 6]) -> [1 2 3 4 5 6]
      + (append '(2 3) '[2 3]) -> (2 3 [2 3])
- [X] first - returns a reference to the first element of a mutable
      collection, or its value for an immutable collection.
- [X] rest - returns a new collection referencing the rest part of
      the old one.
- [X] second, third, fourth etc.
- [X] nth - returns nth element of a collection.
- [X] map - maps an operation to a collection collecting results.
- [X] reduce - maps an operation to a collection reducing it to a
      single value.
- [ ] ? slice - slices a collection creating subcollection.
- [-] ? push, push-back, pop, pop-back.
- ? etc
*** Collection creation:
- [X] list - returns a list consisting of the call args.
- [X] tuple - returns a tuple consisting of the call args.
- [X] set - returns a set consisting of the call args.
- [X] scope - reuturns a scope with call args defined in it.
- ? etc.
** Core:
*** Type predicates:
- [ ] ? Accept multiple args.
- [X] Evaluate to fnord on false, to one of their args otherwise.

- [X] type? - NOT A PREDICATE, returns type tuple of a _single_
      object.
- [X] fnord? - 'yup if an expression is fnord.
- [X] symbol? - symbol if an expression is a symbol.
- [X] number? - number if an expression is a number.
- [X] string? - string if an expression is a string.
- [X] scope? - scope if an expression is a scope.
- [X] function? - function if an expression is a function.
- [X] pure? - pure if an expression is a pure function.
- [X] syntax? - syntax if an expression is a syntax keyword.
- [X] scope? - scope if an expression is repetition, sigh.
- [X] builtin? - builtin if an expression is a builtin.
- [X] immutable? - immutable if an expression is immutable.
- [ ] mutable? - mutable if an expression is not immutable.
*** Type conversions:
- [ ] ! Convert in place if passed a settable reference, or create a copy.
- [ ] ? Return fnord on error.

- [ ] ? string->number - numerical value of a string.
- [ ] ? string->symbol - returns a symbol version of a string.
      (both deprecated because of the (read-from-string))
- [-] tupleof:
        + [X] Makes an immutable tuple version of a passed arg.
        + [ ] ? Should work for atoms aswell.
- [-] listof:
        + [X] Makes a list representation of an arg.
        + [ ] ? Should work for atoms too.
- [-] setof:
        + [X] Makes a set representation of an arg.
        + [ ] ? Should work for atoms too.
- [X] ! stringof - Makes a string representation of a passed arg.
- ? etc
*** Working with numbers:
- [ ] ASMKit functions accept two arguments.
- [ ] ! Generic functions built ontop of ASMKit ones, directly in ASM.
      Return (reduce ASMKitFunc args).
- [ ] ? Do not use the common operators, so they become redefineable.
**** TODO ASMKit:
- [ ] * - a * b
- [ ] + - a + b
- [ ] - - a - b
- [ ] / - a / b
- [ ] mod - a modulo b
**** TODO Generics:
- [ ] sum - generic +
- [ ] mult - generic *
- [ ] sub - generic -
- [ ] div - generic /
- [ ] modulo - generic mod
- ? etc
*** Equality checks:
- [ ] ASMKit versions taking only two args.
- [ ] Generic versions returning first arg on true.
**** TODO ASMKit:
- [ ] eq? - polimorfic equality check.
- [ ] leq? - a <= b
- ? etc
**** TODO Generics:
- [ ] ? equal?/=/== - generic equal?
- [ ] <= - generic leq?
- [ ] >= - generic ((a eq? b) or (not (a leq? b)))
- [ ] < - generic ((not (a eq? b)) and (a leq? b))
- [ ] > - generic ((not (a eq? b)) and (not (a leq? b)))
** IO:
- [ ] ? Using one interface for files, sockets, stdin etc.
*** Input:
- [ ] readln - Unformatted (string) reads.
- [ ] read - Formatted reads.
- [ ] ? load/open - Loads a file for reading (as a Scope/Stream with read
      defined acordingly).
- [ ] ? close - closes an imput stream.
- [ ] eof? - returns 'yup/the object if it has reached EOF.
- ? etc
*** Output:
- [X] write - writes string representation of the args.
- ? etc
** Error:
# Merge with Core?
- [ ] ? error! - throws an error caugth by the REPL.
- [ ] ? warning! - prints a warning/throws an error if 'serious
      bussiness' was enabled..
- [-] ? catch - catches a thrown error. (Name `handle-error'?)
- [ ] ? assert! - checks a condition and throws an error on failure.
- ? etc
** GC:
# Merge with core?
- [ ] collect! - does a collection.
- [ ] minimise! - minimises memory use.
- [ ] stop! - stops GC.
- [ ] resume! - resumes GCs work.
** Math:
- ? Precompiled.
- [ ] sqrt
- [ ] pow
- [ ] exp
- [ ] min/max/clamp
- ? etc
** Parser:
# Merge with core?
- [ ] syntax! - defines a new reader syntax macro.
- [ ] lex - lexes an input string.
- [ ] ? parse - parses an input string. (Name read-from-string).

################################################################################

* THINGS TO DO IN THE INTERPRETER:
# Lists things needing attention in the interpreter.

** Lexical:
# Move this to lang/lexical?
*** Formal grammar description:
- [X] Finish NumberLiteral formal description / split it into several
      numerical values.
- [X] Finish Symbol formal description.
- [X] Add escape sequences and embeds to the String formal
      description.
- [ ] Add all needed keywords.
- [ ] Remove all not needed keywords.
- [ ] ? Think about the formal macro description.
*** Syntax:
- [ ] ! Remove enum Syntax.
- [ ] ! Minimise enum Lexical.
- [X] Split to Lexical and Syntax:
    + [X] CommentStart, EndOfLine etc - Lexical
    + [X] Rest - Syntax
*** Syntax keywords:
- [ ] Sort out which keywords are crucial and leave only those.
- [ ] Sort the list and write proper descriptions.
- [ ] ? Self:
    + ? Used only for representation of Collections/Scopes/Functions.
    + ? Used semanticly as a self reference of an object.
- [ ] ? Embed:
    + ? Rename to something more appropriate.
    + ? Make it evaluate the expression twice.
- [ ] ? Add __scopecall etc keywords.
*** Semantic keywords:
- [ ] ? Add a list of builtin, recognised keywords.
- ? Trash this?
** AST:
*** Type:
*** Semantic analyzis:
- [ ] ? Type primitive used for semantic analyzis.
- [ ] version(safe) toggling parts of semantic analyzis.
- [ ] Type checking, and predictedType field in Expression.
- [-] Arg number and type checking in Callables:
    + [X] Arg number checking.
    + [-] Arg type checking.
    + [ ] AbigiousCall error when types can vary greatly. E.g. Many
          ifs returning many different expressions.
- [ ] ? Arg evaluation list building using thunks.
- [ ] Recursion depth checking.
*** Expression:
- [X] Additional fields:
    + [X] Line number.
    + [X] Filename.
    + [X] Semantic keywords.
- [ ] ? opApply instead of range(), for convinience. Maby both?
- [ ] T value(T)() instead of real value().
- [ ] hash_t toHash();
- [X] bool opEquals(Object);
- [ ] int opCmp(Object);
*** Atom:
- [X] Take the string away from there, make it a proper immutable
      collection.
- [ ] Add more numerical types.
- [ ] ? Add common atomic operations (like math for numbers, etc).
*** Collection:
- [-] call() for Set and List with no implementation for Tuple:
    + [X] call() for Set and List.
    + [ ] No compiled implementation for Tuple.
- [X] Set.call() calling "__setcall".
- [X] List.call() calling "__listcall".
- [X] List evaluating to "__listeval".
- [X] Set evaluating to "__seteval".
- [X] Add "evalKeyword" and "callKeyword" template args to make eval()
      a oneliner.
- [X] Collection specialisation for String.
- [ ] Proper implementation of the Tuple - linked list.
- [ ] Proper implementation of the Set - kind of a BST.
- [ ] Rename List to Vector.
*** Callable:
- [ ] ! Depth parameter for the calls.
- [-] String representation actually showing the callable.
*** Scope:
- [X] ? String representation actually being usefull. (A tuple of
      keys or key/value pairs.)
- [X] One lexical scope of the variables, macros and syntax keywords.
- [ ] Additional scope for the actual syntax.
- [X] define()
- [ ] syntax()
- [X] Remove set().
- [ ] ? Add undefine(string).
- [ ] ? Add merge(Scope).
- [ ] ? Add import(Scope).
- [X] Add isDefined(string).
- [X] Scope.call() calling "__scopecall".
- [X] Fix storing unwanted objects when rebinding symbols.
- [ ] ? Use outside data table and store only indeces.
*** HashTable:
- [ ] ? New syntax: #[(key value)]
- [ ] ? HashTable.call() returning val-ref / (key val-ref) or UnitType.
    + ? Has to return settable ref at all times (for use with set!).
- [ ] ? HashTable.eval() returning Scope.
- [ ] ? Merge this with Scope.
** Kit:
- [ ] ? Move pass() to a separate module.
- [X] Actually write some fooking implementations.
- [ ] Sort out which implementations are crucial for the language.
- [X] Move Scope, Set and List calls there:
    + [X] Set.call()
    + [X] Scope.call()
    + [X] List.call()
- [X] Move Set, List and Tuple evals there:
    + [X] Set.eval()
    + [X] List.eval()
    + [X] Tuple.eval()
- [X] Fix FNORD comparisions:
*** Implementations:
- [-] Fix EMBED, QUOTE and QQOTE on strings.
- [-] Find solution to/report ref parameter delegate bug from
      LAMBDA.
- [ ] Keyword dispatch for Callables declarators.
- [ ] ? Make IMPORT work with default import paths etc.
- [X] Fix SETOF, TUPLEOF, LISTOF.
- [X] GET should evaluate it's args.
- [X] Rename FUNCTION to LAMBDA/ANONYMOUS.
- [ ] ! LAMBDA should accept multiple expressions in a body.
*** Unittests:
- [X] Actually write those.
- [X] Write more of these.
- [ ] Write even more of these.
- [ ] Foookin' unittest, man!
** Parser:
*** Transition:
- [ ] ? Rename to Lexer.
- [ ] Move the parsing into the language (A recursive descent parser,
      probably.)
- [ ] Figure out what recursive functions are actually needed.
- [ ] Write their default implementations.
# Or...
- [ ] Make the parser minimalistic with no extended syntax, nor
      code validation.
- [ ] Rewrite Core to parse on it.
- [ ] Write a recursive descent parser in ASM.
*** DefaultParser:
- [X] Stop ESyntax expansion in symbols. E.g. some$ymbol.
- [ ] Make parse() pretier!
- [ ] Fix number parsing and PhobosBug(TM) workarrounds.
- [ ] ? NumberParser
*** StringParser:
- [ ] ? Plan embedding representation.
- [ ] Actually parsing strings.
- [ ] Recognize escape sequences.
- [ ] Recognize expression embeds.
*** Unittests:
- [ ] Make unittests Syntax independant.
- [X] More preprocess() unittests.
- [X] More tokenize() unittests.
- [ ] ? parse() unittests.
*** Metadata:
- [X] Add file data.
- [X] Add line number data.
- [ ] ? Add column number data.
** Interpreter:
- [ ] ? Move already implemented ASMKit functions to ASM.kit.
- [X] Fix doString() and doFile().
- [ ] ? InterpretingError for file interepretation.
- [-] Fix metadata in error messages.
*** Unittests:
- [X] Actually write those.
- [ ] Write more of these.
- [ ] Write even more of these.
- [ ] Foookin' unittest, man!

################################################################################

* RANDOM IDEAS:
# Lists some ideas yet to be moved to a more apropriate place.

** Loading symbols from a .so:
- [ ] Find a way to walk arround D's unfinished stuff. *awesome happy face*
- [ ] Find a way to precompile libraries.
- [ ] Find a way to load precompiled files into the ASM.
** Collections:
- [ ] Expression[] range() -> Range range()
- [ ] += Range:
      + Containing all required Range methods.
      + opIndex()
      + opSlice()
      + opDollar()
*** correct Tuple:
- [ ] Immutable
- [ ] Made out of ordered pairs for structure sharing.
- [ ] (elements) and (elements , a)
- ? Think about the append problem.
*** correct Set:
- [ ] AVL/Red-Black tree/Heap.
- [ ] Unordered.
- [ ] Multiset.
- [ ] {elements}
*** correct Vector:
- [X] Dynamic array.
- [X] That be it yo.
- [X] [elements]
*** HashTable:
- [ ] #[(key value) (key2 value2)]
*** Scope:
- ? $(contents same as HashTable)
- ? Same as HashTable?
*** Array/String:
- [ ] | atomic elements |
- [ ] "special literal for character string"
** Callables:
*** Functions:
- [ ] ? Purity checks when defining a lambda.
- [ ] Pure functions being memoized by default.
- [ ] ? Simple literals:
      + [ ] [args -> body] - lexically scoped closure.
- [ ] ? Arg dispatch:
      + [ ] (lambda args body) -> 0-INF-ary, args store all the call args.
      + [ ] (lambda (a . b) body) -> N-INF-ary, b stores the rest of
            the call args.
** Error handling:
- [ ] (catch e handler) -> (try e handler0 handler1 ...)
- [ ] handler = (error-object handling-function)
- [ ] (error error-object/string)
** Lazy evaluation:
- [X] Native, first-clas Promise.
- [X] Builtin (lazy e) macro.
- [ ] ? Lazyfy builtins.
- [ ] ? Make it not callable and add builtin (force e) macro.

