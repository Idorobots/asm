################################################################################
# ASM & ASM interpreter TODO file. Use Emacs org-mode to browse!
#
# ? - think/rethink/reimplement
# ! - important
#
#+SEQ_TODO: THINK TODO TEST FIXME DONE
#
# THINK - planning and prototyping phase.
# TODO - proper implementation phase, starting with unittest writing.
# TEST - testing phase, mainly for hindenbug tracking etc.
# FIXME - bugfixing, unbreaking, etc.
# DONE - sweet, sweet nothing.
####################

* TODO ATM:
# Things being done ATM.

** TODO Fix fnord comparisions.
** TODO Metadata and error messages.
** Refucktorisation:
- [ ] ASM modulenames to lowercase.
- [ ] Rename ASM to dasm.
- [ ] ? ASM.interpreter -> dasm/dasm.state.
- [ ] ASM.parser -> dasm.lexer.
- [ ] ASM.AST -> dasm.ast.
- [ ] ASM.kit -> dasm.kit.
- [ ] ? ASM.lexical -> dev/null.
** Optimise function calls and its memory usage.
** Fix the language specs.
** THINK New parser.

################################################################################

* THINK THINGS TO DO IN THE LIBRARY:
# Each category will be a single module.

** TODO Collections:
- [X] Generic for all the collection types.
*** TODO Collection manipulation:
- [-] join - if the second argument is a collection - prepends it the
      the first argument, if it's not a collection - joins both
      arguments into a pair. Creates a new collection.
      Examples:
      + (join! 1 '[1 2 3]) -> [1 1 2 3]
      + (join! '(a b) '[1 2 3]) -> [(a b) 1 2 3]
      + (join! 'a 'b) -> (a b)
- [-] append - if argument types match - appends element or a
      collection to another collection, if types don't match - appends
      the second argument to the collection.
      Creates a new collection.
      Examples:
      + (append! '[1 2 3] 4) -> [1 2 3 4]
      + (append! '[1 2 3] '[4 5 6]) -> [1 2 3 4 5 6]
      + (append! '(2 3) '[2 3]) -> (2 3 [2 3])
- [X] first - returns a reference to the first element of a mutable
      collection, or its value for an immutable collection.
- [X] rest - returns a new collection referencing the rest part of
      the old one.
- [X] second, third, fourth etc.
- [X] nth - returns nth element of a collection.
- [X] map - maps an operation to a collection collecting results.
- [X] reduce - maps an operation to a collection reducing it to a
      single value.
- [ ] ? slice - slices a collection creating subcollection.
- [-] ? push, push-back, pop, pop-back.
- ? etc
*** TEST Collection creation:
- [X] list - returns a list consisting of the call args.
- [X] tuple - returns a tuple consisting of the call args.
- [X] set - returns a set consisting of the call args.
- [X] scope - reuturns a scope with call args defined in it.
- ? etc.
** TODO Core:
*** TODO Type predicates:
- [ ] ? Accept multiple args.
- [X] Evaluate to fnord on false, to one of their args otherwise.

- [X] type? - NOT A PREDICATE, returns type tuple of a _single_
      object.
- [X] fnord? - 'yup if an expression is fnord.
- [X] symbol? - symbol if an expression is a symbol.
- [X] number? - number if an expression is a number.
- [X] string? - string if an expression is a string.
- [X] scope? - scope if an expression is a scope.
- [X] function? - function if an expression is a function.
- [X] pure? - pure if an expression is a pure function.
- [X] syntax? - syntax if an expression is a syntax keyword.
- [X] scope? - scope if an expression is repetition, sigh.
- [X] builtin? - builtin if an expression is a builtin.
- [X] immutable? - immutable if an expression is immutable.
- [ ] mutable? - mutable if an expression is not immutable.
*** TODO Type conversions:
- [ ] ! Convert in place if passed a settable reference, or create a copy.
- [ ] ? Return fnord on error.

- [ ] ? string->number - numerical value of a string.
- [ ] ? string->symbol - returns a symbol version of a string.
      (both deprecated because of the (read-from-string))
- [-] tupleof:
        + [X] Makes an immutable tuple version of a passed arg.
        + [ ] ? Should work for atoms aswell.
- [-] listof:
        + [X] Makes a list representation of an arg.
        + [ ] ? Should work for atoms too.
- [-] setof:
        + [X] Makes a set representation of an arg.
        + [ ] ? Should work for atoms too.
- [X] ! stringof - Makes a string representation of a passed arg.
- ? etc
*** THINK Working with numbers:
- [ ] ASMKit functions accept two arguments.
- [ ] ! Generic functions built ontop of ASMKit ones, directly in ASM.
      Return (reduce ASMKitFunc args).
- [ ] ? Do not use the common operators, so they become redefineable.
**** TODO ASMKit:
- [ ] * - a * b
- [ ] + - a + b
- [ ] - - a - b
- [ ] / - a / b
- [ ] mod - a modulo b
**** TODO Generics:
- [ ] sum - generic +
- [ ] mult - generic *
- [ ] sub - generic -
- [ ] div - generic /
- [ ] modulo - generic mod
- ? etc
*** THINK Equality checks:
- [ ] ASMKit versions taking only two args.
- [ ] Generic versions returning first arg on true.
**** THINK ASMKit:
- [ ] eq? - polimorfic equality check.
- [ ] leq? - a <= b
- ? etc
**** THINK Generics:
- [ ] ? equal?/=/== - generic equal?
- [ ] <= - generic leq?
- [ ] >= - generic ((a eq? b) or (not (a leq? b)))
- [ ] < - generic ((not (a eq? b)) and (a leq? b))
- [ ] > - generic ((not (a eq? b)) and (not (a leq? b)))
** THINK IO:
- [ ] ? Using one interface for files, sockets, stdin etc.
*** THINK Input:
- [ ] readln - Unformatted (string) reads.
- [ ] read - Formatted reads.
- [ ] ? load/open - Loads a file for reading (as a Scope/Stream with read
      defined acordingly).
- [ ] ? close - closes an imput stream.
- [ ] eof? - returns 'yup/the object if it has reached EOF.
- ? etc
*** THINK Output:
- [X] write - writes string representation of the args.
- ? etc
** THINK Error:
# Merge with Core?
- [ ] ? error! - throws an error caugth by the REPL.
- [ ] ? warning! - prints a warning/throws an error if 'serious
      bussiness' was enabled..
- [-] ? catch - catches a thrown error. (Name `handle-error'?)
- [ ] ? assert! - checks a condition and throws an error on failure.
- ? etc
** THINK GC:
# Merge with core?
- [ ] collect! - does a collection.
- [ ] minimise! - minimises memory use.
- [ ] stop! - stops GC.
- [ ] resume! - resumes GCs work.
** THINK Math:
- ? Precompiled.
- [ ] sqrt
- [ ] pow
- [ ] exp
- [ ] min/max/clamp
- ? etc
** THINK Parser:
# Merge with core?
- [ ] syntax! - defines a new reader syntax macro.
- [ ] lex - lexes an input string.
- [ ] ? parse - parses an input string. (Name read-from-string).

################################################################################

* TODO THINGS TO DO IN THE INTERPRETER:
# Lists things needing attention in the interpreter.

** TODO Lexical:
# Move this to lang/lexical?
*** TODO Formal grammar description:
- [X] Finish NumberLiteral formal description / split it into several
      numerical values.
- [X] Finish Symbol formal description.
- [X] Add escape sequences and embeds to the String formal
      description.
- [ ] Add all needed keywords.
- [ ] Remove all not needed keywords.
- [ ] ? Think about the formal macro description.
*** TODO Syntax:                                                      :THINK:
- [ ] ! Remove enum Syntax.
- [ ] ! Minimise enum Lexical.
- [X] Split to Lexical and Syntax:
    + [X] CommentStart, EndOfLine etc - Lexical
    + [X] Rest - Syntax
*** TODO Syntax keywords:                                             :THINK:
- [ ] Sort out which keywords are crucial and leave only those.
- [ ] Sort the list and write proper descriptions.
- [ ] ? Self:
    + ? Used only for representation of Collections/Scopes/Functions.
    + ? Used semanticly as a self reference of an object.
- [ ] ? Embed:
    + ? Rename to something more appropriate.
    + ? Make it evaluate the expression twice.
- [ ] ? Add __scopecall etc keywords.
*** THINK Semantic keywords:                                          :THINK:
- [ ] ? Add a list of builtin, recognised keywords.
- ? Trash this?
** TODO AST:                                                          :THINK:
*** TODO Type:                                                        :THINK:
- [ ] ? Namechange to Types.
*** THINK Semantic analyzis:                                      :IMPORTANT:
- [ ] ? Type primitive used for semantic analyzis.
- [ ] version(safe) toggling parts of semantic analyzis.
- [ ] Type checking, and predictedType field in Expression.
- [-] Arg number and type checking in Callables:
    + [X] Arg number checking.
    + [ ] Arg type checking.
    + [ ] AbigiousCall error when types can vary greatly. E.g. Many
          ifs returning many different expressions.
- [ ] ? Arg evaluation list building using thunks.
- [ ] Recursion depth checking.
*** TODO Expression:                                                  :THINK:
- [X] Additional fields:
    + [X] Line number.
    + [X] Filename.
    + [X] Semantic keywords.
- [ ] ? opApply instead of range(), for convinience. Maby both?
- [ ] T value(T)() instead of real value().
- [ ] hash_t toHash();
- [ ] bool opEquals(Object);
- [ ] int opCmp(Object);
*** TODO Atom:                                                        :THINK:
- [X] Take the string away from there, make it a proper immutable
      collection.
- [ ] Add more numerical types.
- [ ] ? Add common atomic operations (like math for numbers, etc).
*** TODO Collection:                                                  :THINK:
- [-] call() for Set and List with no implementation for Tuple:
    + [X] call() for Set and List.
    + [ ] No compiled implementation for Tuple.
- [X] Set.call() calling "__setcall".
- [X] List.call() calling "__listcall".
- [X] List evaluating to "__listeval".
- [X] Set evaluating to "__seteval".
- [X] Add "evalKeyword" and "callKeyword" template args to make eval()
      a oneliner.
- [X] Collection specialisation for String.
- [ ] ? Collection specialisation for Tuple.
- [ ] ? Proper implementation of the Tuple - linked list.
- [ ] ? Proper implementation of the Set - kind of a BST.
- [ ] Rename List to Array/Vector.
*** TODO Callable:                                                    :THINK:
- [ ] ! Depth parameter for the calls.
- [ ] ? String representation actually showing the callable.
*** TODO Scope:                                                       :THINK:
- [X] ? String representation actually being usefull. (A tuple of
      keys or key/value pairs.)
- [X] One lexical scope of the variables, macros and syntax keywords.
- [ ] Additional scope for the actual syntax..
- [X] define()
- [ ] syntax()
- [X] Remove set().
- [ ] ? Add undefine(string).
- [ ] ? Add merge(Scope).
- [ ] ? Add import(Scope).
- [X] Add isDefined(string).
- [X] Scope.call() calling "__scopecall".
- [X] Fix storing unwanted objects when rebinding symbols.
- [ ] ? Use outside data table and store only indeces.
*** THINK HashTable:
- [ ] ? New syntax: < >
- [ ] ? HashTable.call() returning val-ref / (key val-ref) or UnitType.
    + ? Has to return settable ref at all times (for use with set!).
- [ ] ? HashTable.eval() returning Scope.
- [ ] ? Merge this with Scope.
** TODO Kit:                                                          :THINK:
- [ ] ? Move pass() to a separate module.
- [X] Actually write some fooking implementations.
- [ ] Sort out which implementations are crucial for the language.
- [ ] Move Scope, Set and List calls there:
    + [ ] Set.call()
    + [ ] Scope.call()
    + [ ] List.call()
- [ ] Move Set, List and Tuple evals there:
    + [ ] Set.eval()
    + [ ] List.eval()
    + [ ] Tuple.eval()
- [ ] Fix FNORD comparisions:
    ? 0-Tuple as the unit type and the only false?
*** TODO Implementations:
- [-] Fix EMBED, QUOTE and QQOTE on strings.
- [ ] ? Force double evaluation in a given scope for EMBED?
- [ ] Find solution to/report ref parameter delegate bug from
      LAMBDA.
- [ ] Keyword dispatch for Callables declarators.
- [ ] Make IMPORT work with default import paths etc.
- [ ] Fix SETOF, TUPLEOF, LISTOF.
- [X] GET should evaluate it's args.
- [X] Rename FUNCTION to LAMBDA/ANONYMOUS.
- [ ] ! LAMBDA should accept multiple statements in a body.
*** TODO Unittests:                                               :IMPORTANT:
- [X] Actually write those.
- [ ] Write more of these.
- [ ] Write even more of these.
- [ ] Foookin' unittest, man!
** TODO Parser:                                                       :THINK:
*** THINK Transition:
- [ ] Rename to Lexer.
- [ ] Move the parsing into the language (A recursive descent parser,
      probably.)
- [ ] Figure out what recursive functions are actually needed.
- [ ] Write their default implementations.
# Or...
- [ ] Make the parser minimalistic with no extended syntax, nor
      code validation.
- [ ] Rewrite Core to parse on it.
- [ ] Write a recursive descent parser in ASM.
*** TODO DefaultParser:
- [X] Stop ESyntax expansion in symbols. E.g. some$ymbol.
- [ ] Make parse() pretier!
- [ ] Fix number parsing and PhobosBug(TM) workarrounds.
- [ ] ? NumberParser
*** THINK StringParser:
- [ ] ? Plan embedding representation.
- [ ] Actually parsing strings.
- [ ] Recognize escape sequences.
- [ ] Recognize expression embeds.
*** TODO Unittests:                                         :IMPORTANT:THINK:
- [ ] Make unittests Syntax independant.
- [X] More preprocess() unittests.
- [X] More tokenize() unittests.
- [ ] ? parse() unittests.
*** THINK Metadata:
- [X] Add file data.
- [X] Add line number data.
- [ ] ? Add column number data.
** TODO Interpreter:                                                  :THINK:
- [ ] ? Move already implemented ASMKit functions to ASM.kit.
- [-] Fix doString() and doFile().
- [ ] ? InterpretingError for file interepretation.
- [-] Fix metadata in error messages.
*** TODO Unittests:                                               :IMPORTANT:
- [X] Actually write those.
- [ ] Write more of these.
- [ ] Write even more of these.
- [ ] Foookin' unittest, man!

################################################################################

* THINK RANDOM IDEAS:
# Lists some ideas yet to be moved to a more apropriate place.
** Refactorisation:
*** ast:
- [ ] Type -> Types
- [ ] += Type - containing convinience functions, such as .isInteger()
      etc.
- [ ] += Location containing source metadata - line+column number,
      filename etc.
*** lexer:
- [ ] += Token containing pointer to a position in the input buffer
  (location), value (regex string) and data (the actual token).
*** dasm:
- [ ] Interpreter -> ASM.State /ASM
** Loading symbols from a .so:
- [ ] Find a way to walk arround D's unfinished stuff. *awesome happy face*
- [ ] Find a way to precompile libraries.
- [ ] Find a way to load precompiled files into the ASM.
** Collections:
- [ ] Expression[] range() -> Range range()
- [ ] += Range:
      + Containing all required Range methods.
      + opIndex()
      + opSlice()
      + opDollar()
*** correct Tuple:
- [ ] Immutable
- [ ] Made out of ordered pairs for structure sharing.
- [ ] (elements)
- ? Think about the append problem.
*** correct Set:
- [ ] AVL/Red-Black tree/Heap.
- [ ] Unordered.
- [ ] Nonunique, but compares to unique: (equals? '{1 2 3 3} '{1 2 3})
- [ ] {elements}
*** correct Vector:
- [ ] Dynamic array.
- [ ] That be it yo.
- [ ] [elements]
*** HashTable:
- ? #[key, value key2, value2]
- ? #[(key value) (key2 value2)]
- ? #[key:value key2:value2]
*** Scope:
- ? $(contents same as HashTable)
- ? Same as HashTable?
*** Array/String:
- ? | atomic elements |
- ? "special literal for character string"
** Callables:
*** Functions:
- [ ] Purity checks when defining a lambda.
- [ ] Pure functions being memoized by default.
- [ ] Both lexically and dynamicall scoped functions.
- [ ] ? Simple literals:
      + [ ] [args -> body] - lexically scoped closure.
      + [ ] [args ~> body] - dynamically scoped, "fuzzy" function.
- [ ] ? Arg dispatch:
      + [ ] (lambda args body) -> 0-INF-ary, args store all the call args.
      + [ ] (lambda (a . b) body) -> N-INF-ary, b stores the rest of
            the call args.
** Error handling:
- [ ] (catch e handler) -> (try e handler0 handler1 ...)
- [ ] handler = (error-object handling-function)
- [ ] (error error-object/string)
** Lazy evaluation:
- [ ] Native Promise.
- [ ] Native (lazy e) macro.
- [ ] Native (force e) macro
