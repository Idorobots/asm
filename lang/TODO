################################################################################
# ASM Language Specification TODO
#
# ? - think/rethink/reimplement
# ! - important
#
#+STARTUP: content
#+SEQ_TODO: NEXT WRITE | TWEAK DONE
#
# nothing - planing.
# NEXT - scheduled for starting.
# WRITE - scheduled to be written down in the specs.
# TWEAK - tweaking phase making a feature work with the rest of the
#         language, decides if the feature stays or goes.
# DONE - the feature is stable and will probably stay forever in the language.
####################

* HIGHEST PRIORITY
** Rewrite taking CEK semantics into account.
** Add ASM and BareBones ASM distinction.
* Lexical
** DONE Source code
- Text formatting
- Character sets
- Named character entities & character sequences
** DONE Comments
- Start with a "#"
*** TWEAK Line comments
- Comment opt ( "#"/"!"/" ") - Eg #!/bin/asm
- ? N-line comments - comment out several following lines at
  once - #+2 line 0\nline 1\nline 2
*** TWEAK Expression comments
- Analyzed syntactically.
- Used for debugging and documentation.
- E.g. #(sexp comment), #sexp_comment
**** NEXT Metadata
- ? #@foo bar -> bar with foo metadata
** WRITE Identifiers
- Full Unicode support.
*** TWEAK Naming convention
- CamelCase - types
- camelCase - functions and variables
- ? dash-case

- procedure? - predicates
(bar? foo)

- procedure! - [significant] side effects
(sen! foo 23)

- procedure* - templated version of `procedure'

# Regular function
(function zip (a b)
  (cons (cons (car a) (car b))
        (zip (cdr a) (cdr b))))

# Templated function
(template zip* (func) (a b)
  (cons (func (car a) (car b))
        ((zip* $func) (cdr a) (cdr b))))

- procedure+ - variation of `procedure' with extended functionality

# Padds the shorter list with fnords to match the longer one in length
(zip+ a b --pad)

- %procedure - low level built-in
(%arg-zip args values)

- foo->bar - conversions (from foo to bar)
- barof - generic conversions (to bar)

- *variable* - a global, mutable state
- ? CONSTANT - constant
- ? +constant+ - constant (swap with the next one?)
- _name_ - reserved for internal purposes
- __name - reserved for internal purposes
** STARTED Number literals
*** Integer
*** STARTED Real
*** Complex
*** Fractions
*** ? Named number entities
** String literals
*** STARTED Escape sequences
*** Expression embedding

** Metadata:
- @-prefixed (annotation much).
- #! comment used for metadata?
- ? Allow only for symbols.
- ? Propagate through the AST.

* Types
** Atomic types:
*** Numbers:
- [X] Evaluate to themselves.
*** Symbols:
- [X] Evaluate to their bound expression.
- ? Pass their metadata to their bound expression.

** Collection types:
*** Array:
- [ ] Usable only with atomic types.
- [ ] Packed tightly internally.
- [ ] ? Abstract 'string collection' out of the string:
  + |'s 't 'r \n| - character string. (Same as "str\n".)
  + |0 3 1 2 3| - number string.
- [ ] ! Expression embedding:
  + |1 2 $(+ 1 2) 3|
  + "foo $bar"
**** String:
- [X] Immutable
- [X] Symbol:
  + [X] Evaluate to themselves unless forced to eval by embed
        expression.
  + [X] WYSIWYG meaning they can contain whitespaces and syntax tokens.
- [-] Collection:
  + [ ] Consist of one letter symbols - characters.
- ? Special regex literal - /some regex/:
  + ? Creates a special, callable regex string with common regex
      operations defined. E.g. split, join, replace etc.
  + ? Sed-like regexes. E.g. s/from/to/g
- [X] ! Recognise escape sequences. E.g. "\n" etc
*** Tuple:
- [X] Immutable
- [X] Call the first Callable object in them with the rest of the
      tuple as the call arguments upon their evaluation. (by default)
*** Vector:
- [X] Evaluate to an anonymous function built from the elements. (by
      default)
- [X] Evaluate to "__vectoreval" function with the elements passed as
      the arguments.
- [X] Callable with an index, return a reference to that element. (by
      default)
- [X] Call "__vectorcall" function when called passing call arguments
      and themselves as its arguments.
*** Set:
- [X] Evaluate all the expressions they contain in the source file
      order, returning the last one. (by default)
- [X] Evaluate to "__seteval" function with the elements passed as
      the arguments.
- [X] Callable with multiple predicates, returns subset satisfying
      the predicates. (by default)
- [X] Call "__setcall" function when called passing call arguments
      and themselves as its arguments.
*** HashTable:
- ?
*** Scopes:
- [X] First-class objects.
- [X] Allow binding symbols to other objects.
- [ ] ! Allow imorting symbols from their scope to other scopes.

** Callable types:
*** Functions:
- [X] First-class objects.
- [ ] Pure functions:
    + [ ] Can call only other pure functions.
    + [ ] ? Receive pure+syntax subset of a Scope.
    + [ ] Parallel higher order functions (like map, reduce etc) for
          pure functions.
- [X] Anonymous by default.
- [X] Closures.
- [ ] ? Use "__argDispatcher" function for argument dispatching.
- [ ] Arglist keywords:
    + [ ] ! .ref - passed by reference.
    + [ ] ! .in - passed by reference, but const.
    + [ ] ! .out - passed by reference, but it to fnord.
    + [ ] ! .lazy - toggles lazy evaluation.
    + [ ] ! .optional - makes an argument optional.
    + [ ] !? ... - stores any additional call parameters in a
          collection.
*** Macros:
- [X] First class objects.
- [X] Evaluated before regular evaluation.
- [X] Create new syntax keywords.
- [X] Named by default.
- [ ] ? Use "__argDispatcher" function for argument dispatching.
- [ ] ? Arglist keywords:
    + [ ] ! .optional - makes an argument optional.
    + [ ] !? ... - stores any additional call parameters in a
          collection.

* Language quirks
** Quoting & embedding:
- [X] Quote - returns the argument untouched. Extended syntax - '.
- [X] Quasiquote - returns the argument with embedded
      expressions. Extended syntax - `.
- [X] Embed - embeds an expression in quasiquote and strings,
      evaluates strings, binds variables in pattern matching.
      Extended syntax - $.

** Unit Type:
- [X] 0-Tuple
- [X] `fnord' as alias to the Unit Type.

** Booleans:
- [X] Only one logical false, anything else is considered true.
- [X] Unit Type as the only false.
- [X] () = '() = fnord

** Flow control:
- [X] (if (c1 b1 ...)
          (c2 b2 ...)
          ...)

** Pattern matching:
- [ ] (match e
             (p1 b1 ...)
             (p2 b2 ...)
             ...)
- [ ] Binds escaped symbols from pattern to the actual objects.
- ? Escaped symbols = embeded symbols.
- ? Returns a Scope with the symbols defined in it.

** Backtracking:
- ? Triggered by backtrack expression.
- ? Extended syntax - ?.

** Error handling:
- [ ] (try e
           (h1 b1)
           (h2 b2)
  ...)
- [ ] UnitType for signalising an error?
- [ ] Returning "more than needed" on non-error.
     E.g (member? () '(1 () 3)) -> (() 3)
- [ ] ? error/catch functions.
* RANDOM IDEAS
** Move CodeCube stuff to the apropriate TODO list.
** Think about the comments some more.
- Metadata
- Opts
- Expression comments
- Shebang parameters problem
- Multiline comments

** ASM named call parameters syntax.

(function (foo bar baz)
  (* bar baz))

# ...

(foo (bar . 23) (baz . 5))
# Does not introduce new syntax, but an ambiguity instead.
(foo bar=23 baz=5)
# New syntax, no ambiguity.
(foo --bar 23 --baz 5)
# No new syntax, --foo is the keyword syntax, consistent with the
# shell feel, but slows down parameter dispatch.

[2012-01-29 nie 16:37]
[[file:~/org/TODO::*Do%20the%20SD%20math.][Do the SD math.]]
** Dynamic dispatch
(defmethod foo (bar baz) body) (foo bar baz) <=> ((get bar 'foo)
baz) # Dynamic dispatch
or
(with bar (foo baz)) # With macro
or
(function foo (baz) body) (connect bar foo) # Slots
** Rewrite Spec to use formal grammar/semantics description exactly as implemented in the language.
