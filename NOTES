✓ comments:
    ✓ ##(line comment\n //TODO: Change to # comment\n
    ✓ #(sexp comment), #sexp_comment
✓ booleans:
    ✓ () = fnord = '() = 'fnord => logical false
macros:
    ? (var foo (macro (:keywords args) body)) -> (foo args) -> ((function ($args) !body) args)
    ? additiolan form: (macro name (:keywords args) body)
functions:
    ? pure functions:
        ? can call only other pure functions (pure (params) (body)), receive pure+syntax subset of an Environment
        ? parallel higher order functions (like map, reduce etc)
    keywords:
        (function (:alias :lazy :optional :const :body :etc) (body))
    ✓ additional form: (function name (:keywords args) body)
strings:
    ✓ WYSIWYG symbols (immutable)
    ? special regex literal: /some regex/
    escape sequences "\n" etc
    ? documentation strings
    expression expansion "$(* 2 2) != $'(1 2 3)" -> "4 != (1 2 3)"
    variable expansion "$a != $b" -> "3.14 != 2.71"
quoting & embeeding:
    ✓ (var a '(1 2 $b c))
    '"two is not $(+ 1 1)"
scopes:
    ✓ first-class-objects (var a (scope (var b 3))) (a b) > 3
    ✓ define()
    merge()
    import()
pattern matching:
    ? (matches? ((pattern1 arg) bodyWithBoundVariables1)
                ((pattern2 arg) bodyWithBoundVariables2)
                ((anything arg) someBody))

type predicates:
null?
boolean?
symbol?
integer?
char?
string?
pair?
procedure?

type conversions:
char->integer
integer->char
number->string
string->number
symbol->string
string->symbol

working with integers:
+
-
*
quotient
remainder
=
<
>

working with pairs and lists:
cons
car
cdr
set-car!
set-cdr!
list

polymorphic equality testing:
eq?

input:
load
read
read-char
peek-char
input-port?
open-input-file
close-input-file
eof-object?

output:
write
write-char
output-port?
open-output-file
close-output-file
error
